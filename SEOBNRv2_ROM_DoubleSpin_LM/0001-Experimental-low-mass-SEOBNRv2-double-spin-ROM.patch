From e37ee2e540dca1ee58cee11675c467f750168b25 Mon Sep 17 00:00:00 2001
From: Michael Puerrer <michael.puerrer@ligo.org>
Date: Mon, 13 Apr 2015 12:41:29 +0100
Subject: [PATCH] Experimental low mass SEOBNRv2 double-spin ROM

---
 lalsimulation/src/LALSimIMR.h                      |   59 +
 .../src/LALSimIMRSEOBNRv2ROMDoubleSpinLM.c         | 1385 ++++++++++++++++++++
 lalsimulation/src/LALSimInspiral.c                 |   23 +
 lalsimulation/src/LALSimInspiral.h                 |    1 +
 lalsimulation/src/Makefile.am                      |    1 +
 5 files changed, 1469 insertions(+)
 create mode 100644 lalsimulation/src/LALSimIMRSEOBNRv2ROMDoubleSpinLM.c

diff --git a/lalsimulation/src/LALSimIMR.h b/lalsimulation/src/LALSimIMR.h
index 9c46b4c..0669341 100644
--- a/lalsimulation/src/LALSimIMR.h
+++ b/lalsimulation/src/LALSimIMR.h
@@ -593,6 +593,65 @@ int XLALSimIMRSEOBNRv2ROMDoubleSpinFrequencySequence(
    REAL8 chi2          /**< Dimensionless aligned component spin 2 */
  );
 
+// Low-mass version of SEOBNRv2 ROM double-spin
+
+int XLALSimIMRSEOBNRv2ROMDoubleSpinLM(
+   struct tagCOMPLEX16FrequencySeries **hptilde, /**< Output: Frequency-domain waveform h+ */
+   struct tagCOMPLEX16FrequencySeries **hctilde, /**< Output: Frequency-domain waveform hx */
+   REAL8 phiRef,                                 /**< Phase at reference frequency */
+   REAL8 deltaF,                                 /**< Sampling frequency (Hz) */
+   REAL8 fLow,                                   /**< Starting GW frequency (Hz) */
+   REAL8 fHigh,                                  /**< End frequency; 0 defaults to ringdown cutoff freq */
+   REAL8 fRef,                                   /**< Reference frequency; 0 defaults to fLow */
+   REAL8 distance,                               /**< Distance of source (m) */
+   REAL8 inclination,                            /**< Inclination of source (rad) */
+   REAL8 m1SI,                                   /**< Mass of companion 1 (kg) */
+   REAL8 m2SI,                                   /**< Mass of companion 2 (kg) */
+   REAL8 chi1,                                   /**< Dimensionless aligned component spin 1 */
+   REAL8 chi2                                    /**< Dimensionless aligned component spin 2 */
+);
+
+/** Compute waveform in LAL format at specified frequencies */
+int XLALSimIMRSEOBNRv2ROMDoubleSpinLMFrequencySequence(
+  struct tagCOMPLEX16FrequencySeries **hptilde, /**< Output: Frequency-domain waveform h+ */
+  struct tagCOMPLEX16FrequencySeries **hctilde, /**< Output: Frequency-domain waveform hx */
+  const REAL8Sequence *freqs,                   /**< Frequency points at which to evaluate the waveform (Hz) */
+  REAL8 phiRef,                                 /**< Phase at reference time */
+  REAL8 fRef,                                   /**< Reference frequency (Hz); 0 defaults to fLow */
+  REAL8 distance,                               /**< Distance of source (m) */
+  REAL8 inclination,                            /**< Inclination of source (rad) */
+  REAL8 m1SI,                                   /**< Mass of companion 1 (kg) */
+  REAL8 m2SI,                                   /**< Mass of companion 2 (kg) */
+  REAL8 chi1,                                   /**< Dimensionless aligned component spin 1 */
+  REAL8 chi2                                    /**< Dimensionless aligned component spin 2 */
+);
+
+/**
+ * Compute the time at a given frequency. The origin of time is at the merger.
+ * The allowed frequency range for the input is from Mf = 0.00053 to half the ringdown frequency.
+ */
+int XLALSimIMRSEOBNRv2ROMDoubleSpinLMTimeOfFrequency(
+  REAL8 *t,         /**< Output: time (s) at frequency */
+  REAL8 frequency,  /**< Frequency (Hz) */
+  REAL8 m1SI,       /**< Mass of companion 1 (kg) */
+  REAL8 m2SI,       /**< Mass of companion 2 (kg) */
+  REAL8 chi1,       /**< Dimensionless aligned component spin 1 */
+  REAL8 chi2        /**< Dimensionless aligned component spin 2 */
+);
+
+/**
+ * Compute the frequency at a given time. The origin of time is at the merger.
+ * The frequency range for the output is from Mf = 0.00053 to half the ringdown frequency.
+ */
+int XLALSimIMRSEOBNRv2ROMDoubleSpinLMFrequencyOfTime(
+  REAL8 *frequency,   /**< Output: Frequency (Hz) */
+  REAL8 t,            /**< Time (s) at frequency */
+  REAL8 m1SI,         /**< Mass of companion 1 (kg) */
+  REAL8 m2SI,         /**< Mass of companion 2 (kg) */
+  REAL8 chi1,         /**< Dimensionless aligned component spin 1 */
+  REAL8 chi2          /**< Dimensionless aligned component spin 2 */
+);
+
 
 /**
  * Compute SEOBNRv2 chirp time from interpolant assuming a single-spin.
diff --git a/lalsimulation/src/LALSimIMRSEOBNRv2ROMDoubleSpinLM.c b/lalsimulation/src/LALSimIMRSEOBNRv2ROMDoubleSpinLM.c
new file mode 100644
index 0000000..81461dd
--- /dev/null
+++ b/lalsimulation/src/LALSimIMRSEOBNRv2ROMDoubleSpinLM.c
@@ -0,0 +1,1385 @@
+/*
+ *  Copyright (C) 2014 Michael Puerrer, John Veitch
+ *  Reduced Order Model for SEOBNR
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with with program; see the file COPYING. If not, write to the
+ *  Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ *  MA  02111-1307  USA
+ */
+
+/**
+ * \author Michael Puerrer, John Veitch
+ *
+ * \file
+ *
+ * \brief C code for SEOBNRv2 reduced order model (double spin low mass version).
+ * See CQG 31 195010, 2014, arXiv:1402.4146 for details.
+ *
+ * The binary data files are available at https://dcc.ligo.org/T1400701-v1.
+ * Put the untared data into a location in your LAL_DATA_PATH.
+ *
+ * Parameter ranges:
+ *   0.01 <= eta <= 0.25
+ *   -1 <= chi_i <= 0.99
+ *   Mtot >= 12Msun
+ */
+
+// NOTE:
+// This low mass double-spin SEOBNRv2 ROM consists of two submodels
+// sub1:
+// - /home/mpuer/nsbh/SEOBNRv2_ROM/models/mopttest_DS_M4_core/*.dat 
+// - SEOBNRv2ROM_DS_LM_sub1_*.dat
+// sub2:
+// - /home/mpuer/nsbh/SEOBNRv2_ROM/models/mopttestDS_M4_highchi1_TF2/*.dat 
+// - SEOBNRv2ROM_DS_LM_sub2_*.dat
+  
+#define _XOPEN_SOURCE 500
+
+#ifdef __GNUC__
+#define UNUSED __attribute__ ((unused))
+#else
+#define UNUSED
+#endif
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <math.h>
+#include <complex.h>
+#include <time.h>
+#include <stdbool.h>
+#include <alloca.h>
+#include <string.h>
+#include <libgen.h>
+
+#ifdef LAL_PTHREAD_LOCK
+#include <pthread.h>
+#endif
+
+#include <gsl/gsl_errno.h>
+#include <gsl/gsl_bspline.h>
+#include <gsl/gsl_blas.h>
+#include <gsl/gsl_min.h>
+#include <gsl/gsl_spline.h>
+#include <lal/Units.h>
+#include <lal/SeqFactories.h>
+#include <lal/LALConstants.h>
+#include <lal/XLALError.h>
+#include <lal/FrequencySeries.h>
+#include <lal/Date.h>
+#include <lal/StringInput.h>
+#include <lal/Sequence.h>
+#include <lal/LALStdio.h>
+#include <lal/FileIO.h>
+
+#include <lal/LALSimInspiral.h>
+#include <lal/LALSimIMR.h>
+
+
+/******************************************************************
+ * The double-spin SEOBNRv2 ROM consists of a number of submodels *
+ * for subdomains of the whole parameter space:                   *
+ * These submodels may change in the future.                      *
+ *                                                                *
+ * "Core" submodel 1                                              *
+ * B-spline points: 67x12x12                                      *
+ * Frequency points: {183, 242}                                   *
+ *                                                                *
+ * "High chi1" submodel 2                                         *
+ * B-spline points: 49x23x5                                       *
+ * Frequency points: {183, 242}                                   *
+ *                                                                *
+ *****************************************************************/
+
+
+/********* Input data for spline basis points **************/
+
+// The frequency points are not necessarily the same for all submodels
+
+#define nk_amp_sub1 183  // number of SVD-modes == number of basis functions for amplitude
+#define nk_phi_sub1 242  // number of SVD-modes == number of basis functions for phase
+
+// Frequency points for amplitude and phase
+static const double gA_sub1[] = {0.0001, 0.00010412, 0.00010841, 0.000112876, 0.000117527, \
+0.000122369, 0.00012741, 0.00013266, 0.000138125, 0.000143816, \
+0.000149741, 0.000155911, 0.000162334, 0.000169022, 0.000175986, \
+0.000183237, 0.000190786, 0.000198646, 0.000206831, 0.000215352, \
+0.000224225, 0.000233463, 0.000243081, 0.000253096, 0.000263524, \
+0.000274381, 0.000285685, 0.000297456, 0.000309711, 0.000322471, \
+0.000335757, 0.00034959, 0.000363993, 0.00037899, 0.000394604, \
+0.000410862, 0.000427789, 0.000445414, 0.000463765, 0.000482872, \
+0.000502767, 0.000523481, 0.000545048, 0.000567504, 0.000590885, \
+0.00061523, 0.000640577, 0.000666969, 0.000694448, 0.000723059, \
+0.000752849, 0.000783867, 0.000816162, 0.000849788, 0.000884799, \
+0.000921253, 0.000959208, 0.000998728, 0.00103988, 0.00108272, \
+0.00112733, 0.00117377, 0.00122213, 0.00127248, 0.00132491, \
+0.0013795, 0.00143633, 0.00149551, 0.00155712, 0.00162128, \
+0.00168807, 0.00175762, 0.00183004, 0.00190543, 0.00198394, \
+0.00206567, 0.00215078, 0.00223939, 0.00233166, 0.00242772, \
+0.00252774, 0.00263189, 0.00274032, 0.00285322, 0.00297077, \
+0.00309317, 0.00322061, 0.0033533, 0.00349145, 0.0036353, 0.00378507, \
+0.00394102, 0.00410339, 0.00427245, 0.00444847, 0.00463175, \
+0.00482258, 0.00502127, 0.00522815, 0.00544354, 0.00566782, \
+0.00590133, 0.00614447, 0.00639762, 0.0066612, 0.00693564, \
+0.00722139, 0.00751891, 0.00782869, 0.00815123, 0.00848707, \
+0.00883673, 0.00920081, 0.00957988, 0.00997457, 0.0103855, 0.0108134, \
+0.0112589, 0.0117228, 0.0122058, 0.0127086, 0.0132322, 0.0137774, \
+0.014345, 0.0149361, 0.0155514, 0.0161921, 0.0168592, 0.0175539, \
+0.0182771, 0.0190301, 0.0198141, 0.0206305, 0.0214804, 0.0223654, \
+0.0232869, 0.0242463, 0.0252453, 0.0262854, 0.0273683, 0.0284959, \
+0.0296699, 0.0308923, 0.0321651, 0.0334903, 0.0348701, 0.0363067, \
+0.0378026, 0.03936, 0.0409817, 0.0426701, 0.0444281, 0.0462586, \
+0.0481644, 0.0501488, 0.0522149, 0.0543662, 0.0566061, 0.0589382, \
+0.0613665, 0.0638948, 0.0665273, 0.0692682, 0.072122, 0.0750935, \
+0.0781873, 0.0814086, 0.0847627, 0.0882549, 0.091891, 0.0956769, \
+0.0996188, 0.103723, 0.107996, 0.112446, 0.117079, 0.121902, \
+0.126925, 0.132154, 0.137599, 0.143268, 0.14917, 0.15};
+
+static const double gPhi_sub1[] = {0.0001, 0.00010116, 0.000102339, 0.000103536, 0.000104751, \
+0.000105985, 0.000107239, 0.000108513, 0.000109807, 0.000111122, \
+0.000112457, 0.000113814, 0.000115193, 0.000116594, 0.000118018, \
+0.000119466, 0.000120936, 0.000122432, 0.000123951, 0.000125497, \
+0.000127067, 0.000128664, 0.000130288, 0.000131939, 0.000133619, \
+0.000135326, 0.000137063, 0.00013883, 0.000140627, 0.000142456, \
+0.000144316, 0.000146208, 0.000148134, 0.000150093, 0.000152087, \
+0.000154117, 0.000156182, 0.000158285, 0.000160426, 0.000162605, \
+0.000164824, 0.000167083, 0.000169384, 0.000171727, 0.000174113, \
+0.000176544, 0.00017902, 0.000181542, 0.000184112, 0.00018673, \
+0.000189398, 0.000192118, 0.000194889, 0.000197714, 0.000200593, \
+0.000203529, 0.000206522, 0.000209574, 0.000212686, 0.00021586, \
+0.000219097, 0.000222399, 0.000225768, 0.000229205, 0.000232711, \
+0.00023629, 0.000239942, 0.000243669, 0.000247474, 0.000251358, \
+0.000255324, 0.000259374, 0.000263509, 0.000267732, 0.000272046, \
+0.000276453, 0.000280956, 0.000285556, 0.000290257, 0.000295062, \
+0.000299972, 0.000304993, 0.000310125, 0.000315373, 0.00032074, \
+0.000326228, 0.000331843, 0.000337586, 0.000343463, 0.000349476, \
+0.00035563, 0.000361929, 0.000368377, 0.000374979, 0.000381739, \
+0.000388662, 0.000395753, 0.000403017, 0.00041046, 0.000418086, \
+0.000425901, 0.000433912, 0.000442125, 0.000450545, 0.00045918, \
+0.000468036, 0.000477121, 0.000486442, 0.000496006, 0.000505821, \
+0.000515897, 0.000526241, 0.000536863, 0.000547771, 0.000558976, \
+0.000570487, 0.000582316, 0.000594473, 0.000606969, 0.000619817, \
+0.000633028, 0.000646617, 0.000660596, 0.000674979, 0.000689781, \
+0.000705018, 0.000720705, 0.000736859, 0.000753497, 0.000770639, \
+0.000788302, 0.000806508, 0.000825276, 0.000844628, 0.000864588, \
+0.00088518, 0.000906427, 0.000928358, 0.000950999, 0.000974379, \
+0.000998529, 0.00102348, 0.00104927, 0.00107592, 0.00110348, \
+0.00113199, 0.00116148, 0.00119201, 0.0012236, 0.00125632, \
+0.00129021, 0.00132533, 0.00136172, 0.00139946, 0.00143859, \
+0.00147919, 0.00152132, 0.00156507, 0.00161049, 0.00165769, \
+0.00170673, 0.00175773, 0.00181076, 0.00186593, 0.00192336, \
+0.00198316, 0.00204545, 0.00211036, 0.00217804, 0.00224862, \
+0.00232227, 0.00239915, 0.00247944, 0.00256334, 0.00265104, \
+0.00274277, 0.00283875, 0.00293924, 0.0030445, 0.00315481, \
+0.00327048, 0.00339185, 0.00351925, 0.00365308, 0.00379373, \
+0.00394165, 0.00409731, 0.00426122, 0.00443394, 0.00461604, \
+0.00480819, 0.00501107, 0.00522545, 0.00545214, 0.00569204, \
+0.00594612, 0.00621543, 0.00650112, 0.00680446, 0.00712681, \
+0.00746969, 0.00783473, 0.00822375, 0.00863874, 0.00908187, \
+0.00955558, 0.0100625, 0.0106056, 0.0111881, 0.0118137, 0.0124864, \
+0.0132106, 0.0139913, 0.0148342, 0.0157454, 0.016732, 0.0178019, \
+0.0189639, 0.0202282, 0.0216061, 0.0231105, 0.0247563, 0.0265601, \
+0.0285412, 0.0307217, 0.0331272, 0.035787, 0.0387354, 0.0420119, \
+0.0456631, 0.0497434, 0.054317, 0.0594597, 0.0652616, 0.0718303, \
+0.0792951, 0.0878118, 0.0975694, 0.108799, 0.121784, 0.136875, 0.15};
+
+#define nk_amp_sub2 nk_amp_sub1
+#define nk_phi_sub2 nk_phi_sub1
+#define gA_sub2 gA_sub1
+#define gPhi_sub2 gPhi_sub1
+
+/******* B-spline knots over the parameter space *******/
+static const double etavec_sub1[] = {0.01, 0.011, 0.012, 0.013, 0.015, 0.017, 0.018, 0.02, 0.021, 0.022, \
+0.023, 0.024, 0.025, 0.027, 0.03, 0.035, 0.037, 0.04, 0.042, 0.045, \
+0.048, 0.05, 0.055, 0.06, 0.065, 0.07, 0.075, 0.08, 0.085, 0.09, \
+0.095, 0.1, 0.105, 0.11, 0.12, 0.13, 0.14, 0.15, 0.16, 0.18, 0.2, \
+0.22, 0.23, 0.235, 0.24, 0.241, 0.242, 0.243, 0.244, 0.245, 0.246, \
+0.247, 0.248, 0.2485, 0.2488, 0.249, 0.2491, 0.2492, 0.2493, 0.2494, \
+0.2495, 0.2496, 0.2497, 0.2498, 0.2499, 0.24995, 0.25};
+static const double chi1vec_sub1[] = {-0.9999, -0.8, -0.6, -0.4, -0.2, 0., 0.2, 0.4, 0.6, 0.8, 0.9, \
+0.98999};
+static const double chi2vec_sub1[] = {-0.9999, -0.8, -0.6, -0.4, -0.2, 0., 0.2, 0.4, 0.6, 0.8, 0.9, \
+0.98999};
+
+static const int ncx_sub1 = 67+2;       // points in eta  + 2
+static const int ncy_sub1 = 12+2;       // points in chi1 + 2
+static const int ncz_sub1 = 12+2;       // points in chi2 + 2
+
+
+static const double etavec_sub2[] = {0.01, 0.011, 0.012, 0.013, 0.015, 0.017, 0.018, 0.02, 0.021, 0.022, \
+0.023, 0.024, 0.025, 0.027, 0.03, 0.035, 0.037, 0.04, 0.042, 0.045, \
+0.048, 0.05, 0.055, 0.06, 0.065, 0.07, 0.075, 0.08, 0.085, 0.09, \
+0.095, 0.1, 0.105, 0.11, 0.12, 0.13, 0.14, 0.15, 0.16, 0.18, 0.2, \
+0.22, 0.23, 0.235, 0.24, 0.244, 0.246, 0.248, 0.25};
+static const double chi1vec_sub2[] = {0.4, 0.45, 0.5, 0.55, 0.6, 0.65, 0.68, 0.69, 0.7, 0.71, 0.72, 0.73, \
+0.75, 0.77, 0.79, 0.81, 0.83, 0.85, 0.88, 0.93, 0.96, 0.98, 0.98999};
+static const double chi2vec_sub2[] = {-0.9999, -0.5, 0., 0.5, 0.98999};
+
+static const int ncx_sub2 = 49+2;       // points in eta  + 2
+static const int ncy_sub2 = 23+2;       // points in chi1 + 2
+static const int ncz_sub2 = 5+2;        // points in chi2 + 2
+
+
+#ifdef LAL_PTHREAD_LOCK
+static pthread_once_t SEOBNRv2ROMDoubleSpin_is_initialized = PTHREAD_ONCE_INIT;
+#endif
+
+/*************** type definitions ******************/
+
+typedef struct tagSEOBNRROMdataDS_coeff
+{
+  gsl_vector* c_amp;
+  gsl_vector* c_phi;
+} SEOBNRROMdataDS_coeff;
+
+struct tagSEOBNRROMdataDS_submodel
+{
+  gsl_vector* cvec_amp;      // Flattened amplitude projection coefficients
+  gsl_vector* cvec_phi;      // Flattened phase projection coefficients
+  gsl_matrix *Bamp;          // Reduced SVD basis for amplitude
+  gsl_matrix *Bphi;          // Reduced SVD basis for phase
+  gsl_vector* cvec_amp_pre;  // AMplitude prefactor coefficient
+  int nk_amp;                // Number frequency points for amplitude
+  int nk_phi;                // Number of frequency points for phase
+  const double *gA;          // Sparse frequency points for amplitude
+  const double *gPhi;        // Sparse frequency points for phase
+  const double *etavec;      // B-spline knots in eta
+  const double *chi1vec;     // B-spline knots in chi1
+  const double *chi2vec;     // B-spline knots in chi2
+  int ncx, ncy, ncz;         // Number of points in eta, chi1, chi2
+};
+typedef struct tagSEOBNRROMdataDS_submodel SEOBNRROMdataDS_submodel;
+
+struct tagSEOBNRROMdataDS
+{
+  UINT4 setup;
+  SEOBNRROMdataDS_submodel* sub1;
+  SEOBNRROMdataDS_submodel* sub2;
+};
+typedef struct tagSEOBNRROMdataDS SEOBNRROMdataDS;
+
+static SEOBNRROMdataDS __lalsim_SEOBNRv2ROMDS_data;
+
+typedef int (*load_dataPtr)(const char*, gsl_vector *, gsl_vector *, gsl_matrix *, gsl_matrix *, gsl_vector *);
+
+typedef struct tagSplineData
+{
+  gsl_bspline_workspace *bwx;
+  gsl_bspline_workspace *bwy;
+  gsl_bspline_workspace *bwz;
+} SplineData;
+
+/**************** Internal functions **********************/
+
+static void SEOBNRv2ROMDoubleSpin_Init_LALDATA(void);
+static int SEOBNRv2ROMDoubleSpin_Init(const char dir[]);
+static bool SEOBNRv2ROMDoubleSpin_IsSetup(void);
+
+static int SEOBNRROMdataDS_Init(SEOBNRROMdataDS *romdata, const char dir[]);
+static void SEOBNRROMdataDS_Cleanup(SEOBNRROMdataDS *romdata);
+
+static int SEOBNRROMdataDS_Init_submodel(
+  SEOBNRROMdataDS_submodel **submodel,
+  const int nk_amp,
+  const int nk_phi,
+  const double *gA,
+  const double *gPhi,
+  const double *etavec,
+  const double *chi1vec,
+  const double *chi2vec,
+  const int ncx,
+  const int ncy,
+  const int ncz,
+  const char dir[],
+  load_dataPtr load_data
+);
+
+static void SEOBNRROMdataDS_Cleanup_submodel(SEOBNRROMdataDS_submodel *submodel);
+
+/**
+ * Core function for computing the ROM waveform.
+ * Interpolate projection coefficient data and evaluate coefficients at desired (q, chi).
+ * Construct 1D splines for amplitude and phase.
+ * Compute strain waveform from amplitude and phase.
+*/
+static int SEOBNRv2ROMDoubleSpinLMCore(
+  COMPLEX16FrequencySeries **hptilde,
+  COMPLEX16FrequencySeries **hctilde,
+  double phiRef,
+  double fRef,
+  double distance,
+  double inclination,
+  double Mtot_sec,
+  double eta,
+  double chi1,
+  double chi2,
+  const REAL8Sequence *freqs, /* Frequency points at which to evaluate the waveform (Hz) */
+  double deltaF
+  /* If deltaF > 0, the frequency points given in freqs are uniformly spaced with
+   * spacing deltaF. Otherwise, the frequency points are spaced non-uniformly.
+   * Then we will use deltaF = 0 to create the frequency series we return. */
+);
+
+static void SEOBNRROMdataDS_coeff_Init(SEOBNRROMdataDS_coeff **romdatacoeff, int nk_amp, int nk_phi);
+static void SEOBNRROMdataDS_coeff_Cleanup(SEOBNRROMdataDS_coeff *romdatacoeff);
+
+static size_t NextPow2(const size_t n);
+static void SplineData_Destroy(SplineData *splinedata);
+static void SplineData_Init(
+  SplineData **splinedata,
+  int ncx,                // Number of points in eta  + 2
+  int ncy,                // Number of points in chi1 + 2
+  int ncz,                // Number of points in chi2 + 2
+  const double *etavec,   // B-spline knots in eta
+  const double *chi1vec,  // B-spline knots in chi1
+  const double *chi2vec   // B-spline knots in chi2
+);
+
+static int read_vector(const char dir[], const char fname[], gsl_vector *v);
+static int read_matrix(const char dir[], const char fname[], gsl_matrix *m);
+
+static int load_data_sub1(const char dir[], gsl_vector *cvec_amp, gsl_vector *cvec_phi, gsl_matrix *Bamp, gsl_matrix *Bphi, gsl_vector *cvec_amp_pre);
+static int load_data_sub2(const char dir[], gsl_vector *cvec_amp, gsl_vector *cvec_phi, gsl_matrix *Bamp, gsl_matrix *Bphi, gsl_vector *cvec_amp_pre);
+
+static int TP_Spline_interpolation_3d(
+  REAL8 eta,                // Input: eta-value for which projection coefficients should be evaluated
+  REAL8 chi1,               // Input: chi1-value for which projection coefficients should be evaluated
+  REAL8 chi2,               // Input: chi2-value for which projection coefficients should be evaluated
+  gsl_vector *cvec_amp,     // Input: data for spline coefficients for amplitude
+  gsl_vector *cvec_phi,     // Input: data for spline coefficients for phase
+  gsl_vector *cvec_amp_pre, // Input: data for spline coefficients for amplitude prefactor
+  int nk_amp,               // number of SVD-modes == number of basis functions for amplitude
+  int nk_phi,               // number of SVD-modes == number of basis functions for phase
+  int ncx,                  // Number of points in eta  + 2
+  int ncy,                  // Number of points in chi1 + 2
+  int ncz,                  // Number of points in chi2 + 2
+  const double *etavec,     // B-spline knots in eta
+  const double *chi1vec,    // B-spline knots in chi1
+  const double *chi2vec,    // B-spline knots in chi2
+  gsl_vector *c_amp,        // Output: interpolated projection coefficients for amplitude
+  gsl_vector *c_phi,        // Output: interpolated projection coefficients for phase
+  REAL8 *amp_pre            // Output: interpolated amplitude prefactor
+);
+
+static int SEOBNRv2ROMDoubleSpinTimeFrequencySetup(
+  gsl_spline **spline_phi,                      // phase spline
+  gsl_interp_accel **acc_phi,                   // phase spline accelerator
+  REAL8 *Mf_final,                              // ringdown frequency in Mf
+  REAL8 *Mtot_sec,                              // total mass in seconds
+  REAL8 m1SI,                                   /**< Mass of companion 1 (kg) */
+  REAL8 m2SI,                                   /**< Mass of companion 2 (kg) */
+  REAL8 chi1,                                   /**< Aligned spin of companion 1 */
+  REAL8 chi2                                    /**< Aligned spin of companion 2 */
+);
+
+/********************* Definitions begin here ********************/
+
+/** Setup SEOBNRv2ROMDoubleSpin model using data files installed in dir
+ */
+int SEOBNRv2ROMDoubleSpin_Init(const char dir[]) {
+  if(__lalsim_SEOBNRv2ROMDS_data.setup) {
+    XLALPrintError("Error: DSEOBNRROMdata was already set up!");
+    XLAL_ERROR(XLAL_EFAILED);
+  }
+
+  SEOBNRROMdataDS_Init(&__lalsim_SEOBNRv2ROMDS_data, dir);
+
+  if(__lalsim_SEOBNRv2ROMDS_data.setup) {
+    return(XLAL_SUCCESS);
+  }
+  else {
+    return(XLAL_EFAILED);
+  }
+}
+
+/** Helper function to check if the SEOBNRv2ROMDoubleSpin model has been initialised */
+bool SEOBNRv2ROMDoubleSpin_IsSetup(void) {
+  if(__lalsim_SEOBNRv2ROMDS_data.setup)
+    return true;
+  else
+    return false;
+}
+
+// Helper functions to read gsl_vector and gsl_matrix data with error checking
+static int read_vector(const char dir[], const char fname[], gsl_vector *v) {
+  char *path=alloca(strlen(dir)+32);
+
+  sprintf(path,"%s/%s", dir, fname);
+  FILE *f = fopen(path, "rb");
+  if (!f) {
+    XLALPrintInfo("%s : Could not find ROM data file at path %s.\n", __func__, path);
+    return(XLAL_FAILURE);
+  }
+  int ret = gsl_vector_fread(f, v);
+  if (ret != 0) {
+    XLALPrintError("%s : Error reading data from %s.\n", __func__, path);
+    return(XLAL_FAILURE);
+  }
+  fclose(f);
+  XLALPrintInfo("%s : sucessfully read ROM data file %s.\n", __func__, path);
+  return(XLAL_SUCCESS);
+}
+
+static int read_matrix(const char dir[], const char fname[], gsl_matrix *m) {
+  char *path=alloca(strlen(dir)+32);
+
+  sprintf(path,"%s/%s", dir, fname);
+  FILE *f = fopen(path, "rb");
+  if (!f) {
+    XLALPrintInfo("%s : Could not find ROM data file at path %s.\n", __func__, path);
+    return(XLAL_FAILURE);
+  }
+  int ret = gsl_matrix_fread(f, m);
+  if (ret != 0) {
+    XLALPrintError("%s : Error reading data from %s.\n", __func__, path);
+    return(XLAL_FAILURE);
+  }
+  fclose(f);
+  XLALPrintInfo("%s : sucessfully read ROM data file %s.\n", __func__, path);
+  return(XLAL_SUCCESS);
+}
+
+// Read binary ROM data for basis functions and coefficients for submodel 1
+static int load_data_sub1(const char dir[], gsl_vector *cvec_amp, gsl_vector *cvec_phi, gsl_matrix *Bamp, gsl_matrix *Bphi, gsl_vector *cvec_amp_pre) {
+  // Load binary data for amplitude and phase spline coefficients and reduced bases as computed in Mathematica
+  // "Core" submodel 1
+  // B-spline points: 67x12x12
+  // Frequency points: {183, 242}
+  int ret = XLAL_SUCCESS;
+  ret |= read_vector(dir, "SEOBNRv2ROM_DS_LM_sub1_Amp_ciall.dat", cvec_amp);
+  ret |= read_vector(dir, "SEOBNRv2ROM_DS_LM_sub1_Phase_ciall.dat", cvec_phi);
+  ret |= read_matrix(dir, "SEOBNRv2ROM_DS_LM_sub1_Bamp_bin.dat", Bamp);
+  ret |= read_matrix(dir, "SEOBNRv2ROM_DS_LM_sub1_Bphase_bin.dat", Bphi);
+  ret |= read_vector(dir, "SEOBNRv2ROM_DS_LM_sub1_AmpPrefac_ci.dat", cvec_amp_pre);
+  return(ret);
+}
+
+// Read binary ROM data for basis functions and coefficients for submodel 2
+static int load_data_sub2(const char dir[], gsl_vector *cvec_amp, gsl_vector *cvec_phi, gsl_matrix *Bamp, gsl_matrix *Bphi, gsl_vector *cvec_amp_pre) {
+  // Load binary data for amplitude and phase spline coefficients and reduced bases as computed in Mathematica
+  // "High chi1" submodel 2
+  // B-spline points: 49x23x5
+  // Frequency points: {183, 242}
+  int ret = XLAL_SUCCESS;
+  ret |= read_vector(dir, "SEOBNRv2ROM_DS_LM_sub2_Amp_ciall.dat", cvec_amp);
+  ret |= read_vector(dir, "SEOBNRv2ROM_DS_LM_sub2_Phase_ciall.dat", cvec_phi);
+  ret |= read_matrix(dir, "SEOBNRv2ROM_DS_LM_sub2_Bamp_bin.dat", Bamp);
+  ret |= read_matrix(dir, "SEOBNRv2ROM_DS_LM_sub2_Bphase_bin.dat", Bphi);
+  ret |= read_vector(dir, "SEOBNRv2ROM_DS_LM_sub2_AmpPrefac_ci.dat", cvec_amp_pre);
+  return(ret);
+}
+
+// Setup B-spline basis functions for given points
+static void SplineData_Init(
+  SplineData **splinedata,
+  int ncx,                // Number of points in eta  + 2
+  int ncy,                // Number of points in chi1 + 2
+  int ncz,                // Number of points in chi2 + 2
+  const double *etavec,   // B-spline knots in eta
+  const double *chi1vec,  // B-spline knots in chi1
+  const double *chi2vec   // B-spline knots in chi2
+)
+{
+  if(!splinedata) exit(1);
+  if(*splinedata) SplineData_Destroy(*splinedata);
+
+  (*splinedata)=XLALCalloc(1,sizeof(SplineData));
+
+  // Set up B-spline basis for desired knots
+  const size_t nbreak_x = ncx-2;  // must have nbreak = n-2 for cubic splines
+  const size_t nbreak_y = ncy-2;  // must have nbreak = n-2 for cubic splines
+  const size_t nbreak_z = ncz-2;  // must have nbreak = n-2 for cubic splines
+
+  // Allocate a cubic bspline workspace (k = 4)
+  gsl_bspline_workspace *bwx = gsl_bspline_alloc(4, nbreak_x);
+  gsl_bspline_workspace *bwy = gsl_bspline_alloc(4, nbreak_y);
+  gsl_bspline_workspace *bwz = gsl_bspline_alloc(4, nbreak_z);
+
+  // Set breakpoints (and thus knots by hand)
+  gsl_vector *breakpts_x = gsl_vector_alloc(nbreak_x);
+  gsl_vector *breakpts_y = gsl_vector_alloc(nbreak_y);
+  gsl_vector *breakpts_z = gsl_vector_alloc(nbreak_z);
+  for (UINT4 i=0; i<nbreak_x; i++)
+    gsl_vector_set(breakpts_x, i, etavec[i]);
+  for (UINT4 j=0; j<nbreak_y; j++)
+    gsl_vector_set(breakpts_y, j, chi1vec[j]);
+  for (UINT4 k=0; k<nbreak_z; k++)
+    gsl_vector_set(breakpts_z, k, chi2vec[k]);
+
+  gsl_bspline_knots(breakpts_x, bwx);
+  gsl_bspline_knots(breakpts_y, bwy);
+  gsl_bspline_knots(breakpts_z, bwz);
+
+  gsl_vector_free(breakpts_x);
+  gsl_vector_free(breakpts_y);
+  gsl_vector_free(breakpts_z);
+
+  (*splinedata)->bwx=bwx;
+  (*splinedata)->bwy=bwy;
+  (*splinedata)->bwz=bwz;
+}
+
+static void SplineData_Destroy(SplineData *splinedata)
+{
+  if(!splinedata) return;
+  if(splinedata->bwx) gsl_bspline_free(splinedata->bwx);
+  if(splinedata->bwy) gsl_bspline_free(splinedata->bwy);
+  if(splinedata->bwz) gsl_bspline_free(splinedata->bwz);
+  XLALFree(splinedata);
+}
+
+// Helper function to perform tensor product spline interpolation with gsl
+// The gsl_vector v contains the ncx x ncy x ncz dimensional coefficient tensor in vector form
+// that should be interpolated and evaluated at position (eta,chi1,chi2).
+static REAL8 Interpolate_Coefficent_Tensor(
+  gsl_vector *v,
+  REAL8 eta,
+  REAL8 chi1,
+  REAL8 chi2,
+  int ncy,
+  int ncz,
+  gsl_bspline_workspace *bwx,
+  gsl_bspline_workspace *bwy,
+  gsl_bspline_workspace *bwz
+) {
+  // Store nonzero cubic (order k=4) B-spline basis functions in the eta and chi directions.
+  gsl_vector *Bx4 = gsl_vector_alloc(4);
+  gsl_vector *By4 = gsl_vector_alloc(4);
+  gsl_vector *Bz4 = gsl_vector_alloc(4);
+
+  size_t isx, isy, isz; // first non-zero spline
+  size_t iex, iey, iez; // last non-zero spline
+  // Evaluate all potentially nonzero cubic B-spline basis functions for
+  // positions (eta,chi) and store them in the vectors Bx4, By4, Bz4.
+  // Since the B-splines are of compact support we only need to store a small
+  // number of basis functions to avoid computing terms that would be zero anyway.
+  // https://www.gnu.org/software/gsl/manual/html_node/Overview-of-B_002dsplines.html#Overview-of-B_002dsplines
+  gsl_bspline_eval_nonzero(eta,  Bx4, &isx, &iex, bwx);
+  gsl_bspline_eval_nonzero(chi1, By4, &isy, &iey, bwy);
+  gsl_bspline_eval_nonzero(chi2, Bz4, &isz, &iez, bwz);
+
+  // Now compute coefficient at desired parameters (q,chi1,chi2)
+  // from C(eta,chi1,chi2) = c_ijk * Beta_i * Bchi1_j * Bchi2_k
+  // while summing over indices i,j,k where the B-splines are nonzero.
+  // Note: in the 2D case we were able to use gsl_matrix c = gsl_matrix_view_vector(&v, ncx, ncy).matrix
+  // to convert vector view of the coefficient matrix to a matrix view.
+  // However, since tensors are not supported in gsl, we have to do the indexing explicitly.
+  double sum = 0;
+  for (int i=0; i<4; i++)
+    for (int j=0; j<4; j++)
+      for (int k=0; k<4; k++) {
+        int ii = isx + i;
+        int jj = isy + j;
+        int kk = isz + k;
+        double cijk = gsl_vector_get(v, (ii*ncy + jj)*ncz + kk);
+        sum += cijk * gsl_vector_get(Bx4, i) * gsl_vector_get(By4, j) * gsl_vector_get(Bz4, k);
+      }
+
+  gsl_vector_free(Bx4);
+  gsl_vector_free(By4);
+  gsl_vector_free(Bz4);
+
+  return sum;
+}
+
+// Interpolate projection coefficients for amplitude and phase over the parameter space (q, chi).
+// The multi-dimensional interpolation is carried out via a tensor product decomposition.
+static int TP_Spline_interpolation_3d(
+  REAL8 eta,                // Input: eta-value for which projection coefficients should be evaluated
+  REAL8 chi1,               // Input: chi1-value for which projection coefficients should be evaluated
+  REAL8 chi2,               // Input: chi2-value for which projection coefficients should be evaluated
+  gsl_vector *cvec_amp,     // Input: data for spline coefficients for amplitude
+  gsl_vector *cvec_phi,     // Input: data for spline coefficients for phase
+  gsl_vector *cvec_amp_pre, // Input: data for spline coefficients for amplitude prefactor
+  int nk_amp,               // number of SVD-modes == number of basis functions for amplitude
+  int nk_phi,               // number of SVD-modes == number of basis functions for phase
+  int ncx,                  // Number of points in eta  + 2
+  int ncy,                  // Number of points in chi1 + 2
+  int ncz,                  // Number of points in chi2 + 2
+  const double *etavec,     // B-spline knots in eta
+  const double *chi1vec,    // B-spline knots in chi1
+  const double *chi2vec,    // B-spline knots in chi2
+  gsl_vector *c_amp,        // Output: interpolated projection coefficients for amplitude
+  gsl_vector *c_phi,        // Output: interpolated projection coefficients for phase
+  REAL8 *amp_pre            // Output: interpolated amplitude prefactor
+) {
+  SplineData *splinedata=NULL;
+  SplineData_Init(&splinedata, ncx, ncy, ncz, etavec, chi1vec, chi2vec);
+
+  gsl_bspline_workspace *bwx=splinedata->bwx;
+  gsl_bspline_workspace *bwy=splinedata->bwy;
+  gsl_bspline_workspace *bwz=splinedata->bwz;
+
+  int N = ncx*ncy*ncz;  // Size of the data matrix for one SVD-mode
+
+  // Evaluate the TP spline for all SVD modes - amplitude
+  for (int k=0; k<nk_amp; k++) { // For each SVD mode
+    gsl_vector v = gsl_vector_subvector(cvec_amp, k*N, N).vector; // Pick out the coefficient matrix corresponding to the k-th SVD mode.
+    REAL8 csum = Interpolate_Coefficent_Tensor(&v, eta, chi1, chi2, ncy, ncz, bwx, bwy, bwz);
+    gsl_vector_set(c_amp, k, csum);
+  }
+
+  // Evaluate the TP spline for all SVD modes - phase
+  for (int k=0; k<nk_phi; k++) {  // For each SVD mode
+    gsl_vector v = gsl_vector_subvector(cvec_phi, k*N, N).vector; // Pick out the coefficient matrix corresponding to the k-th SVD mode.
+    REAL8 csum = Interpolate_Coefficent_Tensor(&v, eta, chi1, chi2, ncy, ncz, bwx, bwy, bwz);
+    gsl_vector_set(c_phi, k, csum);
+  }
+
+  // Evaluate the TP spline for the amplitude prefactor
+  *amp_pre = Interpolate_Coefficent_Tensor(cvec_amp_pre, eta, chi1, chi2, ncy, ncz, bwx, bwy, bwz);
+
+  SplineData_Destroy(splinedata);
+
+  return(0);
+}
+
+static void err_handler(const char *reason, const char *file, int line, int gsl_errno) {
+  XLALPrintError("gsl: %s:%d: %s - %d\n", file, line, reason, gsl_errno);
+}
+
+/* Set up a new ROM submodel, using data contained in dir */
+static int SEOBNRROMdataDS_Init_submodel(
+  SEOBNRROMdataDS_submodel **submodel,
+  const int nk_amp,
+  const int nk_phi,
+  const double *gA,
+  const double *gPhi,
+  const double *etavec,
+  const double *chi1vec,
+  const double *chi2vec,
+  const int ncx,
+  const int ncy,
+  const int ncz,
+  const char dir[],
+  load_dataPtr load_data
+) {
+  int ret = XLAL_FAILURE;
+
+  if(!submodel) exit(1);
+  /* Create storage for submodel structures */
+  if (!*submodel)
+    *submodel = XLALCalloc(1,sizeof(SEOBNRROMdataDS_submodel));
+  else
+    SEOBNRROMdataDS_Cleanup_submodel(*submodel);
+
+  int N = ncx*ncy*ncz; // Total number of points over parameter space = size of the data matrix for one SVD-mode
+
+  // Initalize actual ROM data
+  (*submodel)->cvec_amp = gsl_vector_alloc(N*nk_amp);
+  (*submodel)->cvec_phi = gsl_vector_alloc(N*nk_phi);
+  (*submodel)->Bamp = gsl_matrix_alloc(nk_amp, nk_amp);
+  (*submodel)->Bphi = gsl_matrix_alloc(nk_phi, nk_phi);
+  (*submodel)->cvec_amp_pre = gsl_vector_alloc(N);
+
+  // Load ROM data for this submodel
+  ret=load_data(dir, (*submodel)->cvec_amp, (*submodel)->cvec_phi, (*submodel)->Bamp, (*submodel)->Bphi, (*submodel)->cvec_amp_pre);
+
+  // Initialize other members
+  (*submodel)->nk_amp = nk_amp;
+  (*submodel)->nk_phi = nk_phi;
+  (*submodel)->gA = gA;
+  (*submodel)->gPhi = gPhi;
+  (*submodel)->etavec = etavec;
+  (*submodel)->chi1vec = chi1vec;
+  (*submodel)->chi2vec = chi2vec;
+  (*submodel)->ncx = ncx;
+  (*submodel)->ncy = ncy;
+  (*submodel)->ncz = ncz;
+
+  return ret;
+}
+
+/* Deallocate contents of the given SEOBNRROMdataDS_submodel structure */
+void SEOBNRROMdataDS_Cleanup_submodel(SEOBNRROMdataDS_submodel *submodel) {
+  if(submodel->cvec_amp) gsl_vector_free(submodel->cvec_amp);
+  if(submodel->cvec_phi) gsl_vector_free(submodel->cvec_phi);
+  if(submodel->Bamp) gsl_matrix_free(submodel->Bamp);
+  if(submodel->Bphi) gsl_matrix_free(submodel->Bphi);
+  if(submodel->cvec_amp_pre) gsl_vector_free(submodel->cvec_amp_pre);
+}
+
+/* Set up a new ROM model, using data contained in dir */
+int SEOBNRROMdataDS_Init(SEOBNRROMdataDS *romdata, const char dir[]) {
+  int ret = XLAL_FAILURE;
+
+  /* Create storage for structures */
+  if(romdata->setup) {
+    XLALPrintError("WARNING: You tried to setup the SEOBNRv2ROMDoubleSpin model that was already initialised. Ignoring\n");
+    return (XLAL_FAILURE);
+  }
+
+  gsl_set_error_handler(&err_handler);
+
+  load_dataPtr load_data = &load_data_sub1;
+  ret = SEOBNRROMdataDS_Init_submodel(&(romdata)->sub1, nk_amp_sub1, nk_phi_sub1,
+          gA_sub1, gPhi_sub1, etavec_sub1, chi1vec_sub1, chi2vec_sub1, ncx_sub1, ncy_sub1, ncz_sub1, dir, load_data);
+  if (ret==XLAL_SUCCESS) XLALPrintInfo("%s : submodel 1 loaded sucessfully.\n", __func__);
+
+  load_data = &load_data_sub2;
+  ret |= SEOBNRROMdataDS_Init_submodel(&(romdata)->sub2, nk_amp_sub2, nk_phi_sub2,
+          gA_sub2, gPhi_sub2, etavec_sub2, chi1vec_sub2, chi2vec_sub2, ncx_sub2, ncy_sub2, ncz_sub2, dir, load_data);
+  if (ret==XLAL_SUCCESS) XLALPrintInfo("%s : submodel 2 loaded sucessfully.\n", __func__);
+
+  if(XLAL_SUCCESS==ret)
+    romdata->setup=1;
+  else
+    SEOBNRROMdataDS_Cleanup(romdata);
+
+  return (ret);
+}
+
+/* Deallocate contents of the given SEOBNRROMdataDS structure */
+void SEOBNRROMdataDS_Cleanup(SEOBNRROMdataDS *romdata) {
+  SEOBNRROMdataDS_Cleanup_submodel((romdata)->sub1);
+  XLALFree((romdata)->sub1);
+  (romdata)->sub1 = NULL;
+  romdata->setup=0;
+}
+
+/* Structure for internal use */
+static void SEOBNRROMdataDS_coeff_Init(SEOBNRROMdataDS_coeff **romdatacoeff, int nk_amp, int nk_phi) {
+
+  if(!romdatacoeff) exit(1);
+  /* Create storage for structures */
+  if(!*romdatacoeff)
+    *romdatacoeff=XLALCalloc(1,sizeof(SEOBNRROMdataDS_coeff));
+  else
+    SEOBNRROMdataDS_coeff_Cleanup(*romdatacoeff);
+
+  (*romdatacoeff)->c_amp = gsl_vector_alloc(nk_amp);
+  (*romdatacoeff)->c_phi = gsl_vector_alloc(nk_phi);
+}
+
+/* Deallocate contents of the given SEOBNRROMdataDS_coeff structure */
+static void SEOBNRROMdataDS_coeff_Cleanup(SEOBNRROMdataDS_coeff *romdatacoeff) {
+  if(romdatacoeff->c_amp) gsl_vector_free(romdatacoeff->c_amp);
+  if(romdatacoeff->c_phi) gsl_vector_free(romdatacoeff->c_phi);
+  XLALFree(romdatacoeff);
+}
+
+/* Return the closest higher power of 2  */
+// Note: NextPow(2^k) = 2^k for integer values k.
+static size_t NextPow2(const size_t n) {
+  return 1 << (size_t) ceil(log2(n));
+}
+
+
+/**
+ * Core function for computing the ROM waveform.
+ * Interpolate projection coefficient data and evaluate coefficients at desired (q, chi1, chi2).
+ * Construct 1D splines for amplitude and phase.
+ * Compute strain waveform from amplitude and phase.
+*/
+static int SEOBNRv2ROMDoubleSpinLMCore(
+  COMPLEX16FrequencySeries **hptilde,
+  COMPLEX16FrequencySeries **hctilde,
+  double phiRef,
+  double fRef,
+  double distance,
+  double inclination,
+  double Mtot_sec,
+  double eta,
+  double chi1,
+  double chi2,
+  const REAL8Sequence *freqs_in, /* Frequency points at which to evaluate the waveform (Hz) */
+  double deltaF
+  /* If deltaF > 0, the frequency points given in freqs are uniformly spaced with
+   * spacing deltaF. Otherwise, the frequency points are spaced non-uniformly.
+   * Then we will use deltaF = 0 to create the frequency series we return. */
+  )
+{
+
+  /* Check output arrays */
+  if(!hptilde || !hctilde)
+    XLAL_ERROR(XLAL_EFAULT);
+  SEOBNRROMdataDS *romdata=&__lalsim_SEOBNRv2ROMDS_data;
+  if(*hptilde || *hctilde)
+  {
+    XLALPrintError("(*hptilde) and (*hctilde) are supposed to be NULL, but got %p and %p",(*hptilde),(*hctilde));
+    XLAL_ERROR(XLAL_EFAULT);
+  }
+  int retcode=0;
+
+  /* Select ROM submodel */
+  SEOBNRROMdataDS_submodel *submodel;
+  if (eta < 0.24 && chi1 > 0.4)
+    submodel = romdata->sub2;
+  else
+    submodel = romdata->sub1;
+
+  /* Find frequency bounds */
+  if (!freqs_in) XLAL_ERROR(XLAL_EFAULT);
+  double fLow  = freqs_in->data[0];
+  double fHigh = freqs_in->data[freqs_in->length - 1];
+
+  if(fRef==0.0)
+    fRef=fLow;
+
+  /* Convert to geometric units for frequency */
+  double Mf_ROM_min = fmax(submodel->gA[0], submodel->gPhi[0]);                                   // lowest allowed geometric frequency for ROM
+  double Mf_ROM_max = fmin(submodel->gA[submodel->nk_amp-1], submodel->gPhi[submodel->nk_phi-1]); // highest allowed geometric frequency for ROM
+  double fLow_geom = fLow * Mtot_sec;
+  double fHigh_geom = fHigh * Mtot_sec;
+  double fRef_geom = fRef * Mtot_sec;
+  double deltaF_geom = deltaF * Mtot_sec;
+
+  // Enforce allowed geometric frequency range
+  if (fLow_geom < Mf_ROM_min) {
+    XLALPrintWarning("Starting frequency Mflow=%g is smaller than lowest frequency in ROM Mf=%g. Starting at lowest frequency in ROM.\n", fLow_geom, Mf_ROM_min);
+    fLow_geom = Mf_ROM_min;
+  }
+  if (fHigh_geom == 0 || fHigh_geom > Mf_ROM_max)
+    fHigh_geom = Mf_ROM_max;
+  else if (fHigh_geom < Mf_ROM_min)
+    XLAL_ERROR(XLAL_EDOM, "End frequency %g is smaller than starting frequency %g!\n", fHigh_geom, fLow_geom);
+  if (fRef_geom > Mf_ROM_max)
+    fRef_geom = Mf_ROM_max; // If fref > fhigh we reset fref to default value of cutoff frequency.
+  if (fRef_geom < Mf_ROM_min) {
+    XLALPrintWarning("Reference frequency Mf_ref=%g is smaller than lowest frequency in ROM Mf=%g. Starting at lowest frequency in ROM.\n", fLow_geom, Mf_ROM_min);
+    fRef_geom = Mf_ROM_min;
+  }
+
+  /* Internal storage for waveform coefficiencts */
+  SEOBNRROMdataDS_coeff *romdata_coeff=NULL;
+  SEOBNRROMdataDS_coeff_Init(&romdata_coeff, submodel->nk_amp, submodel->nk_phi);
+  REAL8 amp_pre;
+
+  /* Interpolate projection coefficients and evaluate them at (q,chi1,chi2) */
+  retcode=TP_Spline_interpolation_3d(
+    eta,                       // Input: eta-value for which projection coefficients should be evaluated
+    chi1,                      // Input: chi1-value for which projection coefficients should be evaluated
+    chi2,                      // Input: chi2-value for which projection coefficients should be evaluated
+    submodel->cvec_amp,        // Input: data for spline coefficients for amplitude
+    submodel->cvec_phi,        // Input: data for spline coefficients for phase
+    submodel->cvec_amp_pre,    // Input: data for spline coefficients for amplitude prefactor
+    submodel->nk_amp,          // number of SVD-modes == number of basis functions for amplitude
+    submodel->nk_phi,          // number of SVD-modes == number of basis functions for phase
+    submodel->ncx,             // Number of points in eta  + 2
+    submodel->ncy,             // Number of points in chi1 + 2
+    submodel->ncz,             // Number of points in chi2 + 2
+    submodel->etavec,          // B-spline knots in eta
+    submodel->chi1vec,         // B-spline knots in chi1
+    submodel->chi2vec,         // B-spline knots in chi2
+    romdata_coeff->c_amp,      // Output: interpolated projection coefficients for amplitude
+    romdata_coeff->c_phi,      // Output: interpolated projection coefficients for phase
+    &amp_pre                   // Output: interpolated amplitude prefactor
+  );
+
+  if(retcode!=0) {
+    SEOBNRROMdataDS_coeff_Cleanup(romdata_coeff);
+    XLAL_ERROR(retcode);
+  }
+
+  // Compute function values of amplitude an phase on sparse frequency points by evaluating matrix vector products
+  // amp_pts = B_A^T . c_A
+  // phi_pts = B_phi^T . c_phi
+  gsl_vector* amp_f = gsl_vector_alloc(submodel->nk_amp);
+  gsl_vector* phi_f = gsl_vector_alloc(submodel->nk_phi);
+  gsl_blas_dgemv(CblasTrans, 1.0, submodel->Bamp, romdata_coeff->c_amp, 0.0, amp_f);
+  gsl_blas_dgemv(CblasTrans, 1.0, submodel->Bphi, romdata_coeff->c_phi, 0.0, phi_f);
+
+  // Setup 1d splines in frequency
+  gsl_interp_accel *acc_amp = gsl_interp_accel_alloc();
+  gsl_spline *spline_amp = gsl_spline_alloc(gsl_interp_cspline, submodel->nk_amp);
+  gsl_spline_init(spline_amp, submodel->gA, gsl_vector_const_ptr(amp_f,0), submodel->nk_amp);
+
+  gsl_interp_accel *acc_phi = gsl_interp_accel_alloc();
+  gsl_spline *spline_phi = gsl_spline_alloc(gsl_interp_cspline, submodel->nk_phi);
+  gsl_spline_init(spline_phi, submodel->gPhi, gsl_vector_const_ptr(phi_f,0), submodel->nk_phi);
+
+
+  size_t npts = 0;
+  LIGOTimeGPS tC = {0, 0};
+  UINT4 offset = 0; // Index shift between freqs and the frequency series
+  REAL8Sequence *freqs = NULL;
+  if (deltaF > 0)  { // freqs contains uniform frequency grid with spacing deltaF; we start at frequency 0
+    /* Set up output array with size closest power of 2 */
+    npts = NextPow2(fHigh_geom / deltaF_geom) + 1;
+    if (fHigh_geom < fHigh * Mtot_sec) /* Resize waveform if user wants f_max larger than cutoff frequency */
+      npts = NextPow2(fHigh * Mtot_sec / deltaF_geom) + 1;
+
+    XLALGPSAdd(&tC, -1. / deltaF);  /* coalesce at t=0 */
+    *hptilde = XLALCreateCOMPLEX16FrequencySeries("hptilde: FD waveform", &tC, 0.0, deltaF, &lalStrainUnit, npts);
+    *hctilde = XLALCreateCOMPLEX16FrequencySeries("hctilde: FD waveform", &tC, 0.0, deltaF, &lalStrainUnit, npts);
+
+    // Recreate freqs using only the lower and upper bounds
+    UINT4 iStart = (UINT4) ceil(fLow_geom / deltaF_geom);
+    UINT4 iStop = (UINT4) ceil(fHigh_geom / deltaF_geom);
+    freqs = XLALCreateREAL8Sequence(iStop - iStart);
+    for (UINT4 i=iStart; i<iStop; i++)
+      freqs->data[i-iStart] = i*deltaF_geom;
+
+    offset = iStart;
+  } else { // freqs contains frequencies with non-uniform spacing; we start at lowest given frequency
+    npts = freqs_in->length;
+    *hptilde = XLALCreateCOMPLEX16FrequencySeries("hptilde: FD waveform", &tC, fLow, 0, &lalStrainUnit, npts);
+    *hctilde = XLALCreateCOMPLEX16FrequencySeries("hctilde: FD waveform", &tC, fLow, 0, &lalStrainUnit, npts);
+    offset = 0;
+
+    freqs = XLALCreateREAL8Sequence(freqs_in->length);
+    for (UINT4 i=0; i<freqs_in->length; i++)
+      freqs->data[i] = freqs_in->data[i] * Mtot_sec;
+  }
+
+
+  if (!(hptilde) || !(*hctilde)) XLAL_ERROR(XLAL_EFUNC);
+  memset((*hptilde)->data->data, 0, npts * sizeof(COMPLEX16));
+  memset((*hctilde)->data->data, 0, npts * sizeof(COMPLEX16));
+
+  XLALUnitDivide(&(*hptilde)->sampleUnits, &(*hptilde)->sampleUnits, &lalSecondUnit);
+  XLALUnitDivide(&(*hctilde)->sampleUnits, &(*hctilde)->sampleUnits, &lalSecondUnit);
+
+  COMPLEX16 *pdata=(*hptilde)->data->data;
+  COMPLEX16 *cdata=(*hctilde)->data->data;
+
+  REAL8 cosi = cos(inclination);
+  REAL8 pcoef = 0.5*(1.0 + cosi*cosi);
+  REAL8 ccoef = cosi;
+
+  REAL8 s = 0.5; // Scale polarization amplitude so that strain agrees with FFT of SEOBNRv2
+  double Mtot = Mtot_sec / LAL_MTSUN_SI;
+  double amp0 = Mtot * amp_pre * Mtot_sec * LAL_MRSUN_SI / (distance); // Correct overall amplitude to undo mass-dependent scaling used in ROM
+
+  // Evaluate reference phase for setting phiRef correctly
+  double phase_change = gsl_spline_eval(spline_phi, fRef_geom, acc_phi) - phiRef;
+
+  // Assemble waveform from aplitude and phase
+  for (UINT4 i=0; i<freqs->length; i++) { // loop over frequency points in sequence
+    double f = freqs->data[i];
+    if (f > Mf_ROM_max) continue; // We're beyond the highest allowed frequency; since freqs may not be ordered, we'll just skip the current frequency and leave zero in the buffer
+    int j = i + offset; // shift index for frequency series if needed
+    double A = gsl_spline_eval(spline_amp, f, acc_amp);
+    double phase = gsl_spline_eval(spline_phi, f, acc_phi) - phase_change;
+    COMPLEX16 htilde = s*amp0*A * cexp(I*phase);
+    pdata[j] =      pcoef * htilde;
+    cdata[j] = -I * ccoef * htilde;
+  }
+
+  /* Correct phasing so we coalesce at t=0 (with the definition of the epoch=-1/deltaF above) */
+  if (deltaF > 0)
+    XLAL_PRINT_WARNING("Warning: Depending on specified frequency sequence correction to time of coalescence may not be accurate.\n");
+
+  // Get SEOBNRv2 ringdown frequency for 22 mode
+  // XLALSimInspiralGetFinalFreq wants masses in SI units, so unfortunately we need to convert back
+  double q = (1.0 + sqrt(1.0 - 4.0*eta) - 2.0*eta) / (2.0*eta);
+  double Mtot_SI = Mtot_sec / LAL_MTSUN_SI * LAL_MSUN_SI;
+  double m1_SI = Mtot_SI * 1.0/(1.0+q);
+  double m2_SI = Mtot_SI * q/(1.0+q);
+  double Mf_final = XLALSimInspiralGetFinalFreq(m1_SI, m2_SI, 0,0,chi1, 0,0,chi2, SEOBNRv2) * Mtot_sec;
+
+  UINT4 L = freqs->length;
+  // prevent gsl interpolation errors
+  if (Mf_final > freqs->data[L-1])
+    Mf_final = freqs->data[L-1];
+  if (Mf_final < freqs->data[0])
+    XLAL_ERROR(XLAL_EDOM, "f_ringdown < f_min");
+
+  // Time correction is t(f_final) = 1/(2pi) dphi/df (f_final)
+  // We compute the dimensionless time correction t/M since we use geometric units.
+  REAL8 t_corr = gsl_spline_eval_deriv(spline_phi, Mf_final, acc_phi) / (2*LAL_PI);
+  XLAL_PRINT_INFO("t_corr [s] = %g\n", t_corr * Mtot_sec);
+
+  // Now correct phase
+  for (UINT4 i=0; i<freqs->length; i++) { // loop over frequency points in sequence
+    double f = freqs->data[i];
+    int j = i + offset; // shift index for frequency series if needed
+    pdata[j] *= cexp(-2*LAL_PI * I * f * t_corr);
+    cdata[j] *= cexp(-2*LAL_PI * I * f * t_corr);
+  }
+
+  XLALDestroyREAL8Sequence(freqs);
+
+  gsl_spline_free(spline_amp);
+  gsl_spline_free(spline_phi);
+  gsl_interp_accel_free(acc_amp);
+  gsl_interp_accel_free(acc_phi);
+  gsl_vector_free(amp_f);
+  gsl_vector_free(phi_f);
+  SEOBNRROMdataDS_coeff_Cleanup(romdata_coeff);
+
+  return(XLAL_SUCCESS);
+}
+
+/** Compute waveform in LAL format at specified frequencies */
+int XLALSimIMRSEOBNRv2ROMDoubleSpinLMFrequencySequence(
+  struct tagCOMPLEX16FrequencySeries **hptilde, /**< Output: Frequency-domain waveform h+ */
+  struct tagCOMPLEX16FrequencySeries **hctilde, /**< Output: Frequency-domain waveform hx */
+  const REAL8Sequence *freqs,                   /**< Frequency points at which to evaluate the waveform (Hz) */
+  REAL8 phiRef,                                 /**< Phase at reference time */
+  REAL8 fRef,                                   /**< Reference frequency (Hz); 0 defaults to fLow */
+  REAL8 distance,                               /**< Distance of source (m) */
+  REAL8 inclination,                            /**< Inclination of source (rad) */
+  REAL8 m1SI,                                   /**< Mass of companion 1 (kg) */
+  REAL8 m2SI,                                   /**< Mass of companion 2 (kg) */
+  REAL8 chi1,                                   /**< Dimensionless aligned component spin 1 */
+  REAL8 chi2                                    /**< Dimensionless aligned component spin 2 */
+)
+{
+  /* Internally we need m1 > m2, so change around if this is not the case */
+  if (m1SI < m2SI) {
+    // Swap m1 and m2
+    double m1temp = m1SI;
+    double chi1temp = chi1;
+    m1SI = m2SI;
+    chi1 = chi2;
+    m2SI = m1temp;
+    chi2 = chi1temp;
+  }
+
+  /* Get masses in terms of solar mass */
+  double mass1 = m1SI / LAL_MSUN_SI;
+  double mass2 = m2SI / LAL_MSUN_SI;
+  double Mtot = mass1+mass2;
+  double eta = mass1 * mass2 / (Mtot*Mtot);    /* Symmetric mass-ratio */
+  double Mtot_sec = Mtot * LAL_MTSUN_SI; /* Total mass in seconds */
+
+  if (!freqs) XLAL_ERROR(XLAL_EFAULT);
+
+  if ( chi1 < -1.0 || chi2 < -1.0 || chi1 > 0.99 || chi2 > 0.99 ) {
+    XLALPrintError( "XLAL Error - %s: chi1 or chi2 smaller than -1 or larger than 0.99!\nSEOBNRv2ROMDoubleSpin is only available for spins in the range -1 <= a/M <= 0.99.\n", __func__);
+    XLAL_ERROR( XLAL_EDOM );
+  }
+
+  if (eta<0.01 || eta > 0.25) {
+    XLALPrintError( "XLAL Error - %s: eta (%f) smaller than 0.01 or unphysical!\nSEOBNRv2ROMDoubleSpin is only available for spins in the range 0.01 <= eta <= 0.25.\n", __func__,eta);
+    XLAL_ERROR( XLAL_EDOM );
+  }
+
+  // Load ROM data if not loaded already
+#ifdef LAL_PTHREAD_LOCK
+  (void) pthread_once(&SEOBNRv2ROMDoubleSpin_is_initialized, SEOBNRv2ROMDoubleSpin_Init_LALDATA);
+#else
+  SEOBNRv2ROMDoubleSpin_Init_LALDATA();
+#endif
+
+  // Call the internal core function with deltaF = 0 to indicate that freqs is non-uniformly
+  // spaced and we want the strain only at these frequencies
+  int retcode = SEOBNRv2ROMDoubleSpinLMCore(hptilde,hctilde,
+            phiRef, fRef, distance, inclination, Mtot_sec, eta, chi1, chi2, freqs, 0);
+
+  return(retcode);
+}
+
+/** Compute waveform in LAL format */
+int XLALSimIMRSEOBNRv2ROMDoubleSpinLM(
+  struct tagCOMPLEX16FrequencySeries **hptilde, /**< Output: Frequency-domain waveform h+ */
+  struct tagCOMPLEX16FrequencySeries **hctilde, /**< Output: Frequency-domain waveform hx */
+  REAL8 phiRef,                                 /**< Phase at reference time */
+  REAL8 deltaF,                                 /**< Sampling frequency (Hz) */
+  REAL8 fLow,                                   /**< Starting GW frequency (Hz) */
+  REAL8 fHigh,                                  /**< End frequency; 0 defaults to Mf=0.14 */
+  REAL8 fRef,                                   /**< Reference frequency (Hz); 0 defaults to fLow */
+  REAL8 distance,                               /**< Distance of source (m) */
+  REAL8 inclination,                            /**< Inclination of source (rad) */
+  REAL8 m1SI,                                   /**< Mass of companion 1 (kg) */
+  REAL8 m2SI,                                   /**< Mass of companion 2 (kg) */
+  REAL8 chi1,                                   /**< Dimensionless aligned component spin 1 */
+  REAL8 chi2)                                   /**< Dimensionless aligned component spin 2 */
+{
+  /* Internally we need m1 > m2, so change around if this is not the case */
+  if (m1SI < m2SI) {
+    // Swap m1 and m2
+    double m1temp = m1SI;
+    double chi1temp = chi1;
+    m1SI = m2SI;
+    chi1 = chi2;
+    m2SI = m1temp;
+    chi2 = chi1temp;
+  }
+
+  /* Get masses in terms of solar mass */
+  double mass1 = m1SI / LAL_MSUN_SI;
+  double mass2 = m2SI / LAL_MSUN_SI;
+  double Mtot = mass1+mass2;
+  double eta = mass1 * mass2 / (Mtot*Mtot);    /* Symmetric mass-ratio */
+  double Mtot_sec = Mtot * LAL_MTSUN_SI;       /* Total mass in seconds */
+
+  if(fRef==0.0)
+    fRef=fLow;
+
+  if ( chi1 < -1.0 || chi2 < -1.0 || chi1 > 0.99 || chi2 > 0.99 ) {
+    XLALPrintError( "XLAL Error - %s: chi1 or chi2 smaller than -1 or larger than 0.99!\nSEOBNRv2ROMDoubleSpin is only available for spins in the range -1 <= a/M <= 0.99.\n", __func__);
+    XLAL_ERROR( XLAL_EDOM );
+  }
+
+  if (eta < 0.01 || eta > 0.25) {
+    XLALPrintError( "XLAL Error - %s: eta smaller than 0.01 or unphysical!\nSEOBNRv2ROMDoubleSpin is only available for spins in the range 0.01 <= eta <= 0.25.\n", __func__);
+    XLAL_ERROR( XLAL_EDOM );
+  }
+
+  // Load ROM data if not loaded already
+#ifdef LAL_PTHREAD_LOCK
+  (void) pthread_once(&SEOBNRv2ROMDoubleSpin_is_initialized, SEOBNRv2ROMDoubleSpin_Init_LALDATA);
+#else
+  SEOBNRv2ROMDoubleSpin_Init_LALDATA();
+#endif
+
+  // Use fLow, fHigh, deltaF to compute freqs sequence
+  // Instead of building a full sequency we only transfer the boundaries and let
+  // the internal core function do the rest (and properly take care of corner cases).
+  REAL8Sequence *freqs = XLALCreateREAL8Sequence(2);
+  freqs->data[0] = fLow;
+  freqs->data[1] = fHigh;
+
+  int retcode = SEOBNRv2ROMDoubleSpinLMCore(hptilde,hctilde,
+            phiRef, fRef, distance, inclination, Mtot_sec, eta, chi1, chi2, freqs, deltaF);
+
+  XLALDestroyREAL8Sequence(freqs);
+
+  return(retcode);
+}
+
+
+// Auxiliary function to perform setup of phase spline for t(f) and f(t) functions
+static int SEOBNRv2ROMDoubleSpinTimeFrequencySetup(
+  gsl_spline **spline_phi,                      // phase spline
+  gsl_interp_accel **acc_phi,                   // phase spline accelerator
+  REAL8 *Mf_final,                              // ringdown frequency in Mf
+  REAL8 *Mtot_sec,                              // total mass in seconds
+  REAL8 m1SI,                                   /**< Mass of companion 1 (kg) */
+  REAL8 m2SI,                                   /**< Mass of companion 2 (kg) */
+  REAL8 chi1,                                   /**< Aligned spin of companion 1 */
+  REAL8 chi2                                    /**< Aligned spin of companion 2 */
+)
+{
+  /* Get masses in terms of solar mass */
+  double mass1 = m1SI / LAL_MSUN_SI;
+  double mass2 = m2SI / LAL_MSUN_SI;
+  double Mtot = mass1 + mass2;
+  double eta = mass1 * mass2 / (Mtot*Mtot);    /* Symmetric mass-ratio */
+  *Mtot_sec = Mtot * LAL_MTSUN_SI; /* Total mass in seconds */
+
+  // Load ROM data if not loaded already
+#ifdef LAL_PTHREAD_LOCK
+  (void) pthread_once(&SEOBNRv2ROMDoubleSpin_is_initialized, SEOBNRv2ROMDoubleSpin_Init_LALDATA);
+#else
+  SEOBNRv2ROMDoubleSpin_Init_LALDATA();
+#endif
+
+  SEOBNRROMdataDS *romdata=&__lalsim_SEOBNRv2ROMDS_data;
+
+  /* Select ROM submodel */
+  SEOBNRROMdataDS_submodel *submodel;
+  if (eta < 0.24 && chi1 > 0.4)
+    submodel = romdata->sub2;
+  else
+    submodel = romdata->sub1;
+
+  /* Internal storage for w.f. coefficiencts */
+  SEOBNRROMdataDS_coeff *romdata_coeff=NULL;
+  SEOBNRROMdataDS_coeff_Init(&romdata_coeff, submodel->nk_amp, submodel->nk_phi);
+  REAL8 amp_pre;
+
+  /* Interpolate projection coefficients and evaluate them at (eta,chi1,chi2) */
+  int retcode=TP_Spline_interpolation_3d(
+    eta,                       // Input: eta-value for which projection coefficients should be evaluated
+    chi1,                      // Input: chi1-value for which projection coefficients should be evaluated
+    chi2,                      // Input: chi2-value for which projection coefficients should be evaluated
+    submodel->cvec_amp,        // Input: data for spline coefficients for amplitude
+    submodel->cvec_phi,        // Input: data for spline coefficients for phase
+    submodel->cvec_amp_pre,    // Input: data for spline coefficients for amplitude prefactor
+    submodel->nk_amp,          // number of SVD-modes == number of basis functions for amplitude
+    submodel->nk_phi,          // number of SVD-modes == number of basis functions for phase
+    submodel->ncx,             // Number of points in eta  + 2
+    submodel->ncy,             // Number of points in chi1 + 2
+    submodel->ncz,             // Number of points in chi2 + 2
+    submodel->etavec,          // B-spline knots in eta
+    submodel->chi1vec,         // B-spline knots in chi1
+    submodel->chi2vec,         // B-spline knots in chi2
+    romdata_coeff->c_amp,      // Output: interpolated projection coefficients for amplitude
+    romdata_coeff->c_phi,      // Output: interpolated projection coefficients for phase
+    &amp_pre                   // Output: interpolated amplitude prefactor
+  );
+
+  if(retcode!=0) {
+    SEOBNRROMdataDS_coeff_Cleanup(romdata_coeff);
+    XLAL_ERROR(retcode);
+  }
+
+  // Compute function values of phase on sparse frequency points by evaluating matrix vector products
+  // phi_pts = B_phi^T . c_phi
+  gsl_vector* phi_f = gsl_vector_alloc(submodel->nk_phi);
+  gsl_blas_dgemv(CblasTrans, 1.0, submodel->Bphi, romdata_coeff->c_phi, 0.0, phi_f);
+
+  // Setup 1d phase spline in frequency
+  *acc_phi = gsl_interp_accel_alloc();
+  *spline_phi = gsl_spline_alloc(gsl_interp_cspline, submodel->nk_phi);
+  gsl_spline_init(*spline_phi, submodel->gPhi, gsl_vector_const_ptr(phi_f,0), submodel->nk_phi);
+
+  // Get SEOBNRv2 ringdown frequency for 22 mode
+  double q = (1.0 + sqrt(1.0 - 4.0*eta) - 2.0*eta) / (2.0*eta);
+  double Mtot_SI = *Mtot_sec / LAL_MTSUN_SI * LAL_MSUN_SI;
+  double m1_SI = Mtot_SI * 1.0/(1.0+q);
+  double m2_SI = Mtot_SI * q/(1.0+q);
+  *Mf_final = XLALSimInspiralGetFinalFreq(m1_SI, m2_SI, 0,0,chi1, 0,0,chi2, SEOBNRv2) * (*Mtot_sec);
+
+  gsl_vector_free(phi_f);
+  SEOBNRROMdataDS_coeff_Cleanup(romdata_coeff);
+
+  return(XLAL_SUCCESS);
+}
+
+/**
+* Compute the time at a given frequency. The origin of time is at the merger.
+* The allowed frequency range for the input is from Mf = 0.00053 to half the ringdown frequency.
+*/
+int XLALSimIMRSEOBNRv2ROMDoubleSpinLMTimeOfFrequency(
+  REAL8 *t,         /**< Output: time (s) at frequency */
+  REAL8 frequency,  /**< Frequency (Hz) */
+  REAL8 m1SI,       /**< Mass of companion 1 (kg) */
+  REAL8 m2SI,       /**< Mass of companion 2 (kg) */
+  REAL8 chi1,       /**< Dimensionless aligned component spin 1 */
+  REAL8 chi2        /**< Dimensionless aligned component spin 2 */
+)
+{
+  /* Internally we need m1 > m2, so change around if this is not the case */
+  if (m1SI < m2SI) {
+    // Swap m1 and m2
+    double m1temp = m1SI;
+    double chi1temp = chi1;
+    m1SI = m2SI;
+    chi1 = chi2;
+    m2SI = m1temp;
+    chi2 = chi1temp;
+  }
+
+  // Set up phase spline
+  gsl_spline *spline_phi;
+  gsl_interp_accel *acc_phi;
+  double Mf_final, Mtot_sec;
+  int ret = SEOBNRv2ROMDoubleSpinTimeFrequencySetup(&spline_phi, &acc_phi, &Mf_final, &Mtot_sec, m1SI, m2SI, chi1, chi2);
+  if(ret != 0)
+    XLAL_ERROR(ret);
+
+  // ROM frequency bounds in Mf
+  double Mf_ROM_min = 0.0001;
+  double Mf_ROM_max = 0.15;
+
+  // Time correction is t(f_final) = 1/(2pi) dphi/df (f_final)
+  double t_corr = gsl_spline_eval_deriv(spline_phi, Mf_final, acc_phi) / (2*LAL_PI); // t_corr / M
+  XLAL_PRINT_INFO("t_corr[s] = %g\n", t_corr * Mtot_sec);
+
+  double Mf = frequency * Mtot_sec;
+  if (Mf < Mf_ROM_min || Mf > Mf_ROM_max)
+    XLAL_ERROR(XLAL_EDOM, "Frequency %g is outside allowed frequency range.\n", frequency);
+
+  // Compute time relative to origin at merger
+  double time_M = gsl_spline_eval_deriv(spline_phi, frequency * Mtot_sec, acc_phi) / (2*LAL_PI) - t_corr;
+  *t = time_M * Mtot_sec;
+
+  gsl_spline_free(spline_phi);
+  gsl_interp_accel_free(acc_phi);
+
+  return(XLAL_SUCCESS);
+}
+
+/**
+ * Compute the frequency at a given time. The origin of time is at the merger.
+ * The frequency range for the output is from Mf = 0.00053 to half the ringdown frequency.
+ */
+int XLALSimIMRSEOBNRv2ROMDoubleSpinLMFrequencyOfTime(
+  REAL8 *frequency,   /**< Output: Frequency (Hz) */
+  REAL8 t,            /**< Time (s) at frequency */
+  REAL8 m1SI,         /**< Mass of companion 1 (kg) */
+  REAL8 m2SI,         /**< Mass of companion 2 (kg) */
+  REAL8 chi1,         /**< Dimensionless aligned component spin 1 */
+  REAL8 chi2          /**< Dimensionless aligned component spin 2 */
+)
+{
+  /* Internally we need m1 > m2, so change around if this is not the case */
+  if (m1SI < m2SI) {
+    // Swap m1 and m2
+    double m1temp = m1SI;
+    double chi1temp = chi1;
+    m1SI = m2SI;
+    chi1 = chi2;
+    m2SI = m1temp;
+    chi2 = chi1temp;
+  }
+
+  // Set up phase spline
+  gsl_spline *spline_phi;
+  gsl_interp_accel *acc_phi;
+  double Mf_final, Mtot_sec;
+  int ret = SEOBNRv2ROMDoubleSpinTimeFrequencySetup(&spline_phi, &acc_phi, &Mf_final, &Mtot_sec, m1SI, m2SI, chi1, chi2);
+  if(ret != 0)
+    XLAL_ERROR(ret);
+
+  // ROM frequency bounds in Mf
+  double Mf_ROM_min = 0.0001;
+
+  // Time correction is t(f_final) = 1/(2pi) dphi/df (f_final)
+  double t_corr = gsl_spline_eval_deriv(spline_phi, Mf_final, acc_phi) / (2*LAL_PI); // t_corr / M
+  XLAL_PRINT_INFO("t_corr[s] = %g\n", t_corr * Mtot_sec);
+
+  // Assume for now that we only care about f(t) *before* merger so that f(t) - f_ringdown >= 0.
+  // Assume that we only need to cover the frequency range [f_min, f_ringdown/2].
+  int N = 20;
+  double log_f_pts[N];
+  double log_t_pts[N];
+  double log_f_min   = log(Mf_ROM_min);
+  double log_f_rng_2 = log(Mf_final/2.0);
+  double dlog_f = (log_f_rng_2 - log_f_min) / (N-1);
+
+  // Set up data in log-log space
+  for (int i=0; i<N; i++) {
+    log_f_pts[i] = log_f_rng_2 - i*dlog_f; // gsl likes the x-values to be monotonically increasing
+    // Compute time relative to origin at merger
+    double time_M = gsl_spline_eval_deriv(spline_phi, exp(log_f_pts[i]), acc_phi) / (2*LAL_PI) - t_corr;
+    log_t_pts[i] = log(time_M * Mtot_sec);
+  }
+
+  // Check whether time is in bounds
+  double t_rng_2 = exp(log_t_pts[0]);   // time of f_ringdown/2
+  double t_min   = exp(log_t_pts[N-1]); // time of f_min
+  if (t < t_rng_2 || t > t_min)
+    XLAL_ERROR(XLAL_EDOM, "The frequency of time %g is outside allowed frequency range.\n", t);
+
+  // create new spline for data
+  gsl_interp_accel *acc = gsl_interp_accel_alloc();
+  gsl_spline *spline = gsl_spline_alloc(gsl_interp_cspline, N);
+  gsl_spline_init(spline, log_t_pts, log_f_pts, N);
+
+  *frequency = exp(gsl_spline_eval(spline, log(t), acc)) / Mtot_sec;
+
+  gsl_spline_free(spline);
+  gsl_interp_accel_free(acc);
+  gsl_spline_free(spline_phi);
+  gsl_interp_accel_free(acc_phi);
+
+  return(XLAL_SUCCESS);
+}
+
+
+
+/** Setup SEOBNRv2ROMDoubleSpin model using data files installed in $LAL_DATA_PATH
+ */
+void SEOBNRv2ROMDoubleSpin_Init_LALDATA(void)
+{
+  if (SEOBNRv2ROMDoubleSpin_IsSetup()) return;
+
+  // If we find one ROM datafile in a directory listed in LAL_DATA_PATH,
+  // then we expect the remaining datafiles to also be there.
+  char datafile[] = "SEOBNRv2ROM_DS_LM_sub1_Phase_ciall.dat";
+
+  char *path = XLALFileResolvePath(datafile);
+  if (path==NULL)
+    XLAL_ERROR_VOID(XLAL_EIO, "Unable to resolve data file %s in $LAL_DATA_PATH\n", datafile);
+  char *dir = dirname(path);
+  int ret = SEOBNRv2ROMDoubleSpin_Init(dir);
+  XLALFree(path);
+
+  if(ret!=XLAL_SUCCESS)
+    XLAL_ERROR_VOID(XLAL_FAILURE, "Unable to find SEOBNRv2ROMDoubleSpin_LM data files in $LAL_DATA_PATH\n");
+}
diff --git a/lalsimulation/src/LALSimInspiral.c b/lalsimulation/src/LALSimInspiral.c
index 44e3c49..1be397a 100644
--- a/lalsimulation/src/LALSimInspiral.c
+++ b/lalsimulation/src/LALSimInspiral.c
@@ -2818,6 +2818,20 @@ int XLALSimInspiralChooseFDWaveform(
                     phiRef, deltaF, f_min, f_max, f_ref, r, i, m1, m2, S1z, S2z);
             break;
 
+        case SEOBNRv2_ROM_DoubleSpin_LM:
+            /* Waveform-specific sanity checks */
+            if( !XLALSimInspiralWaveformFlagsIsDefault(waveFlags) )
+                ABORT_NONDEFAULT_WAVEFORM_FLAGS(waveFlags);
+            if( !checkTransverseSpinsZero(S1x, S1y, S2x, S2y) )
+                ABORT_NONZERO_TRANSVERSE_SPINS(waveFlags);
+            if( !checkTidesZero(lambda1, lambda2) )
+                ABORT_NONZERO_TIDES(waveFlags);
+            if( f_ref != 0.)
+                XLALPrintWarning("XLAL Warning - %s: This approximant does not use f_ref. The reference phase will be defined at coalescence.\n", __func__);
+
+            ret = XLALSimIMRSEOBNRv2ROMDoubleSpinLM(hptilde, hctilde,
+                    phiRef, deltaF, f_min, f_max, f_ref, r, i, m1, m2, S1z, S2z);
+            break;
 
         case IMRPhenomP:
             /* Waveform-specific sanity checks */
@@ -3783,6 +3797,7 @@ int XLALSimInspiralImplementedFDApproximants(
         case SEOBNRv1_ROM_DoubleSpin:
         case SEOBNRv2_ROM_SingleSpin:
         case SEOBNRv2_ROM_DoubleSpin:
+        case SEOBNRv2_ROM_DoubleSpin_LM:
         //case TaylorR2F4:
         case TaylorF2:
         case SpinTaylorF2:
@@ -3916,6 +3931,10 @@ int XLALGetApproximantFromString(const CHAR *inString)
   {
     return SEOBNRv2_ROM_SingleSpin;
   }
+  else if ( strstr(inString, "SEOBNRv2_ROM_DoubleSpin_LM" ) )
+  {
+    return SEOBNRv2_ROM_DoubleSpin_LM;
+  }
   else if ( strstr(inString, "SEOBNRv2_ROM_DoubleSpin" ) )
   {
     return SEOBNRv2_ROM_DoubleSpin;
@@ -4103,6 +4122,8 @@ char* XLALGetStringFromApproximant(Approximant approximant)
       return strdup("SEOBNRv2_ROM_SingleSpin");
     case SEOBNRv2_ROM_DoubleSpin:
       return strdup("SEOBNRv2_ROM_DoubleSpin");
+    case SEOBNRv2_ROM_DoubleSpin_LM:
+      return strdup("SEOBNRv2_ROM_DoubleSpin_LM");
     case IMRPhenomFA:
       return strdup("IMRPhenomFA");
     case IMRPhenomFB:
@@ -4345,6 +4366,7 @@ int XLALSimInspiralGetSpinSupportFromApproximant(Approximant approx){
     case SEOBNRv1_ROM_DoubleSpin:
     case SEOBNRv2_ROM_SingleSpin:
     case SEOBNRv2_ROM_DoubleSpin:
+    case SEOBNRv2_ROM_DoubleSpin_LM:
     case TaylorR2F4:
     case IMRPhenomFB:
     case FindChirpSP:
@@ -4417,6 +4439,7 @@ int XLALSimInspiralApproximantAcceptTestGRParams(Approximant approx){
     case SEOBNRv1_ROM_DoubleSpin:
     case SEOBNRv2_ROM_SingleSpin:
     case SEOBNRv2_ROM_DoubleSpin:
+    case SEOBNRv2_ROM_DoubleSpin_LM:
     case IMRPhenomA:
     case IMRPhenomB:
     case IMRPhenomFA:
diff --git a/lalsimulation/src/LALSimInspiral.h b/lalsimulation/src/LALSimInspiral.h
index 2277520..c1985f1 100644
--- a/lalsimulation/src/LALSimInspiral.h
+++ b/lalsimulation/src/LALSimInspiral.h
@@ -257,6 +257,7 @@ typedef enum {
    SEOBNRv1_ROM_DoubleSpin, /**< Double-spin frequency domain reduced order model of spin-aligned EOBNR model SEOBNRv1 See [Purrer:2014fza] */
    SEOBNRv2_ROM_SingleSpin, /**< Single-spin frequency domain reduced order model of spin-aligned EOBNR model SEOBNRv2 */
    SEOBNRv2_ROM_DoubleSpin, /**< Double-spin frequency domain reduced order model of spin-aligned EOBNR model SEOBNRv2 */
+   SEOBNRv2_ROM_DoubleSpin_LM, /**< Low-mass Double-spin frequency domain reduced order model of spin-aligned EOBNR model SEOBNRv2 */
    HGimri,		/**< Time domain inspiral-merger-ringdown waveform for quasi-circular intermediate mass-ratio inspirals [Huerta & Gair arXiv:1009.1985]*/
    IMRPhenomA,		/**< Time domain (non-spinning) inspiral-merger-ringdown waveforms generated from the inverse FFT of IMRPhenomFA  */
    IMRPhenomB,		/**< Time domain (non-precessing spins) inspiral-merger-ringdown waveforms generated from the inverse FFT of IMRPhenomFB */
diff --git a/lalsimulation/src/Makefile.am b/lalsimulation/src/Makefile.am
index db56baa..f83494d 100644
--- a/lalsimulation/src/Makefile.am
+++ b/lalsimulation/src/Makefile.am
@@ -101,6 +101,7 @@ liblalsimulation_la_SOURCES = \
 	LALSimIMRSEOBNRv1ROMDoubleSpin.c \
 	LALSimIMRSEOBNRv2ROMSingleSpin.c \
 	LALSimIMRSEOBNRv2ROMDoubleSpin.c \
+	LALSimIMRSEOBNRv2ROMDoubleSpinLM.c \
 	LALSimIMRSEOBNRv2ChirpTime.c \
 	LALSimIMRPhenom.c \
 	LALSimIMRPhenomC.c \
-- 
1.8.5.3

